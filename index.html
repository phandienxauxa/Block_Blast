<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Block Blast - Tetris Classic</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 10px;
            overflow: hidden;
            touch-action: pan-y;
        }

        .game-container {
            background: rgba(15, 20, 35, 0.9);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5), 
                        0 0 30px rgba(82, 183, 136, 0.1);
            max-width: 500px;
            width: 100%;
            border: 2px solid rgba(82, 183, 136, 0.2);
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .title {
            font-size: 28px;
            font-weight: bold;
            color: #52b788;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(82, 183, 136, 0.5);
            letter-spacing: 3px;
        }

        .scores {
            display: flex;
            justify-content: space-around;
            gap: 15px;
            margin-bottom: 15px;
        }

        .score-box {
            background: rgba(82, 183, 136, 0.1);
            padding: 10px 20px;
            border-radius: 10px;
            border: 1px solid rgba(82, 183, 136, 0.3);
            color: #b7e4c7;
            font-weight: bold;
            flex: 1;
            text-align: center;
        }

        .score-label {
            font-size: 11px;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .score-value {
            font-size: 22px;
            margin-top: 5px;
            color: #52b788;
        }

        .grid-container {
            background: rgba(10, 15, 25, 0.8);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            position: relative;
            border: 2px solid rgba(82, 183, 136, 0.15);
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 3px;
            margin: 0 auto;
            max-width: 400px;
        }

        .cell {
            aspect-ratio: 1;
            background: rgba(30, 40, 60, 0.5);
            border-radius: 3px;
            transition: all 0.2s ease;
            border: 1px solid rgba(82, 183, 136, 0.1);
        }

        .cell.filled {
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3),
                        0 0 5px rgba(82, 183, 136, 0.2);
        }

        .cell.preview {
            opacity: 0.6;
            border: 2px solid #52b788;
            box-shadow: 0 0 10px rgba(82, 183, 136, 0.4);
        }

        .cell.invalid-preview {
            opacity: 0.4;
            border: 2px solid #e63946;
            box-shadow: 0 0 10px rgba(230, 57, 70, 0.4);
        }

        .cell.highlight {
            animation: pulse 0.5s ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { 
                transform: scale(1); 
                box-shadow: 0 0 5px rgba(82, 183, 136, 0.3);
            }
            50% { 
                transform: scale(1.08); 
                box-shadow: 0 0 20px rgba(82, 183, 136, 0.8);
            }
        }

        .cell.will-clear {
            animation: willClear 0.8s ease-in-out infinite;
            border-color: #52b788 !important;
        }

        @keyframes willClear {
            0%, 100% { 
                box-shadow: 0 0 8px rgba(82, 183, 136, 0.4),
                            inset 0 0 8px rgba(82, 183, 136, 0.2);
            }
            50% { 
                box-shadow: 0 0 15px rgba(82, 183, 136, 0.8),
                            inset 0 0 12px rgba(82, 183, 136, 0.4);
                border-color: #52b788;
            }
        }

        .pieces-container {
            display: flex;
            justify-content: space-around;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .piece-slot {
            background: rgba(30, 40, 60, 0.6);
            border-radius: 10px;
            padding: 15px;
            min-width: 100px;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            transition: all 0.3s ease;
            border: 1px solid rgba(82, 183, 136, 0.2);
            flex: 1;
            max-width: 140px;
        }

        .piece-slot:hover {
            transform: translateY(-3px);
            border-color: rgba(82, 183, 136, 0.5);
            box-shadow: 0 5px 15px rgba(82, 183, 136, 0.2);
        }

        .piece-slot.dragging {
            opacity: 0.3;
        }

        .piece {
            display: grid;
            gap: 2px;
            pointer-events: none;
        }

        .piece-cell {
            width: 20px;
            height: 20px;
            border-radius: 2px;
            transition: all 0.2s ease;
        }

        .piece-cell.filled {
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.4),
                        0 0 3px rgba(82, 183, 136, 0.3);
        }

        .dragging-piece {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            transform: translate(-50%, -50%) scale(1.2);
            opacity: 0.9;
            filter: drop-shadow(0 0 10px rgba(82, 183, 136, 0.5));
            transition: none;
        }

        .dragging-piece.mobile-offset {
            transform: translate(-50%, calc(-50% - 80px)) scale(1.2);
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .btn {
            background: linear-gradient(135deg, #52b788 0%, #40916c 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 15px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Courier New', monospace;
            letter-spacing: 1px;
            border: 1px solid rgba(82, 183, 136, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(82, 183, 136, 0.4);
            background: linear-gradient(135deg, #40916c 0%, #2d6a4f 100%);
        }

        .btn:active {
            transform: translateY(0);
        }

        .game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            animation: fadeIn 0.3s ease;
        }

        .game-over-overlay.show {
            display: flex;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .game-over-content {
            background: rgba(15, 20, 35, 0.95);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            animation: slideUp 0.3s ease;
            border: 2px solid rgba(82, 183, 136, 0.3);
        }

        @keyframes slideUp {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .game-over-title {
            font-size: 36px;
            font-weight: bold;
            color: #52b788;
            margin-bottom: 20px;
            text-shadow: 0 0 15px rgba(82, 183, 136, 0.6);
            letter-spacing: 2px;
        }

        .final-score {
            font-size: 24px;
            color: #b7e4c7;
            margin-bottom: 20px;
        }

        .combo-effect {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: #52b788;
            background: rgba(10, 15, 25, 0.85);
            padding: 20px 40px;
            border-radius: 15px;
            text-shadow: 0 0 20px rgba(82, 183, 136, 1),
                         0 0 40px rgba(82, 183, 136, 0.8);
            pointer-events: none;
            animation: comboAnim 1.2s ease-out forwards;
            z-index: 2000;
            letter-spacing: 3px;
            border: 2px solid rgba(82, 183, 136, 0.5);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8),
                        0 0 20px rgba(82, 183, 136, 0.3);
        }

        @keyframes comboAnim {
            0% {
                transform: translate(-50%, -50%) scale(0.3);
                opacity: 0;
            }
            30% {
                opacity: 1;
                transform: translate(-50%, -55%) scale(1.3);
            }
            70% {
                opacity: 1;
                transform: translate(-50%, -65%) scale(1.1);
            }
            100% {
                transform: translate(-50%, -80%) scale(1);
                opacity: 0;
            }
        }

        .author {
            text-align: center;
            margin-top: 15px;
            color: #52b788;
            font-size: 11px;
            opacity: 0.5;
            letter-spacing: 1px;
        }

        .color-cyan { background: #2a9d8f; }
        .color-blue { background: #457b9d; }
        .color-orange { background: #e76f51; }
        .color-yellow { background: #e9c46a; }
        .color-green { background: #52b788; }
        .color-purple { background: #7209b7; }
        .color-red { background: #d62828; }

        @media (max-width: 480px) {
            .title {
                font-size: 22px;
            }
            
            .score-box {
                padding: 8px 12px;
            }
            
            .score-value {
                font-size: 18px;
            }
            
            .piece-cell {
                width: 16px;
                height: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <div class="title">BLOCK BLAST</div>
            <div class="scores">
                <div class="score-box">
                    <div class="score-label">Best</div>
                    <div class="score-value" id="highest">0</div>
                </div>
                <div class="score-box">
                    <div class="score-label">Score</div>
                    <div class="score-value" id="score">0</div>
                </div>
            </div>
        </div>

        <div class="grid-container">
            <div class="grid" id="grid"></div>
        </div>

        <div class="pieces-container" id="pieces"></div>

        <div class="controls">
            <button class="btn" onclick="restartGame()">⟳ NEW GAME</button>
        </div>

        <div class="author">
            Author: Duc Thien khong biet code HTML
        </div>
    </div>

    <div class="game-over-overlay" id="gameOverOverlay">
        <div class="game-over-content">
            <div class="game-over-title">GAME OVER</div>
            <div class="final-score">
                SCORE: <span id="finalScore">0</span>
            </div>
            <button class="btn" onclick="restartGame()">PLAY AGAIN</button>
        </div>
    </div>

    <script>
        const GRID_SIZE = 8;
        const TETRIS_COLORS = [
            '#2a9d8f', '#457b9d', '#e76f51', '#e9c46a', 
            '#52b788', '#7209b7', '#d62828'
        ];

        const SHAPES = {
            easy: [
                [[1]],
                [[1, 1]],
                [[1], [1]]
            ],
            medium: [
                [[1, 1, 1]],                    // thanh ngang 3 ô
                [[1], [1], [1]],                // thanh dọc 3 ô
                [[1, 1], [1, 1]],               // ô vuông 2x2
                [[1, 0], [1, 1]],               // chữ L ngắn
                [[1, 1], [1, 0]],               // chữ L ngắn ngược
                [[1, 1], [0, 1]],               // chữ L ngắn ngược ngược
                [[1, 1, 1], [1, 0, 0]],         // chữ L dài
                [[1, 0, 0], [1, 1, 1]],         // chữ L dài ngược 
                [[1, 1, 1], [0, 0, 1]],         // chữ L dài ngược 1
                [[0, 1], [0, 1], [1, 1]],       // chữ L dài chuẩn
                [[1, 0], [1, 0], [1, 1]],       // chữ L dài chuẩn 1
                [[1, 1], [1, 0], [1, 0]],       // chữ L dài chuẩn ngược
            ],
            hard: [
                [[1, 1, 1, 1]],                         // thanh dài 4 ô
                [[1], [1], [1], [1]],                   // thanh dọc 4 ô
                [[1, 1, 1], [0, 1, 0]],                 // tam giác hướng dưới
                [[0, 1, 0], [1, 1, 1]],                 // tam giác hướng lên
                [[0, 1], [1, 1], [0, 1]],               // tam giác bên trái
                [[1, 1, 0], [0, 1, 1]],                 // bậc thang bên trái
                [[0, 1, 1], [1, 1, 0]],                 // bậc thang bên phải
                [[1, 0], [1, 1], [0, 1]],               // bậc thang hướng lên trên
                [[0, 1], [1, 1], [1, 0]],               // bậc thang hướng lên trên ngược
                [[1, 1, 1], [1, 1, 1]],                 // hình chữ nhật 2x3
                [[1, 1], [1, 1], [1, 1]],               // hình chữ nhật 2x3 dựng đứng
                [[1, 1, 1], [1, 0, 0], [1, 0, 0]],      // chữ L siêu dài ngược
                [[1, 1, 1], [0, 0, 1], [0, 0, 1]],      // chữ L siêu dài ngược ngược
                [[1, 1, 1, 1, 1]],                      // thanh dài 5 ô
                [[1], [1], [1], [1], [1]],              // thanh dọc 5 ô
                [[1, 0], [0, 1]],                       // chéo trái
                [[0, 1], [1, 0]],                       // chéo phải
                [[1, 1, 1], [1, 1, 1], [1, 1, 1]],      // ô vuông 3x3
                [[1, 0, 0], [0, 1, 0], [0, 0, 1]],      // chéo trái dài 
                [[0, 0, 1], [0, 1, 0], [1, 0, 0]],      // chéo phải dài
            ]
        };

        const COMBO_MESSAGES = {
            2: { text: 'NICE!', color: '#52b788' },
            3: { text: 'GREAT!', color: '#e9c46a' },
            4: { text: 'EXCELLENT!', color: '#e76f51' },
            5: { text: 'AMAZING!', color: '#7209b7' },
            6: { text: 'INCREDIBLE!', color: '#d62828' }
        };

        let game = {
            grid: Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null)),
            score: 0,
            highest: 0,
            pieces: [],
            draggingPiece: null,
            draggingIndex: -1,
            touchStartPos: null,
            isMobile: false
        };

        function detectMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
                || ('ontouchstart' in window);
        }

        game.isMobile = detectMobile();

        function initGrid() {
            const gridEl = document.getElementById('grid');
            gridEl.innerHTML = '';
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.index = i;
                gridEl.appendChild(cell);
            }
        }

        function drawGrid() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach((cell, i) => {
                const row = Math.floor(i / GRID_SIZE);
                const col = i % GRID_SIZE;
                const value = game.grid[row][col];
                
                if (value) {
                    cell.style.background = value;
                    cell.classList.add('filled');
                } else {
                    cell.style.background = 'rgba(30, 40, 60, 0.5)';
                    cell.classList.remove('filled');
                }
                cell.classList.remove('preview', 'invalid-preview', 'highlight');
            });
        }

        function canPlace(shape, row, col) {
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        const newR = row + r;
                        const newC = col + c;
                        if (newR < 0 || newR >= GRID_SIZE || newC < 0 || newC >= GRID_SIZE) {
                            return false;
                        }
                        if (game.grid[newR][newC]) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function canPlayWithPieces(pieces, grid) {
            for (let piece of pieces) {
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        if (canPlaceOnGrid(piece.shape, row, col, grid)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function canPlaceOnGrid(shape, row, col, grid) {
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        const newR = row + r;
                        const newC = col + c;
                        if (newR < 0 || newR >= GRID_SIZE || newC < 0 || newC >= GRID_SIZE) {
                            return false;
                        }
                        if (grid[newR][newC]) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function generateSmartPieces() {
            const maxAttempts = 50;
            let attempts = 0;
            
            while (attempts < maxAttempts) {
                attempts++;
                const pieces = [];
                
                for (let i = 0; i < 3; i++) {
                    // Tỷ lệ: Easy 15%, Medium 35%, Hard 50%
                    const rand = Math.random();
                    let difficulty;
                    if (rand < 0.15) {
                        difficulty = 'easy';
                    } else if (rand < 0.50) {
                        difficulty = 'medium';
                    } else {
                        difficulty = 'hard';
                    }
                    
                    const shapeList = SHAPES[difficulty];
                    const shape = shapeList[Math.floor(Math.random() * shapeList.length)];
                    const color = TETRIS_COLORS[Math.floor(Math.random() * TETRIS_COLORS.length)];
                    
                    pieces.push({ shape: JSON.parse(JSON.stringify(shape)), color, difficulty });
                }
                
                if (canPlayWithPieces(pieces, game.grid)) {
                    return pieces;
                }
            }
            
            return [
                { shape: [[1]], color: TETRIS_COLORS[0], difficulty: 'easy' },
                { shape: [[1, 1]], color: TETRIS_COLORS[1], difficulty: 'easy' },
                { shape: [[1], [1]], color: TETRIS_COLORS[2], difficulty: 'easy' }
            ];
        }

        function drawPieces() {
            const container = document.getElementById('pieces');
            container.innerHTML = '';
            
            game.pieces.forEach((piece, index) => {
                const slot = document.createElement('div');
                slot.className = 'piece-slot';
                slot.dataset.index = index;
                
                const pieceEl = createPieceElement(piece);
                slot.appendChild(pieceEl);
                
                slot.addEventListener('mousedown', (e) => startDrag(e, index));
                slot.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startDrag(e.touches[0], index);
                });
                
                container.appendChild(slot);
            });
        }

        function createPieceElement(piece) {
            const pieceEl = document.createElement('div');
            pieceEl.className = 'piece';
            pieceEl.style.gridTemplateColumns = `repeat(${piece.shape[0].length}, 20px)`;
            
            piece.shape.forEach(row => {
                row.forEach(cell => {
                    const cellEl = document.createElement('div');
                    cellEl.className = 'piece-cell';
                    if (cell) {
                        cellEl.classList.add('filled');
                        cellEl.style.background = piece.color;
                    } else {
                        cellEl.style.background = 'transparent';
                    }
                    pieceEl.appendChild(cellEl);
                });
            });
            
            return pieceEl;
        }

        function startDrag(e, index) {
            game.draggingIndex = index;
            game.draggingPiece = game.pieces[index];
            game.touchStartPos = { x: e.clientX || e.pageX, y: e.clientY || e.pageY };
            
            const slots = document.querySelectorAll('.piece-slot');
            slots[index].classList.add('dragging');
            
            createDraggingPiece(e);
        }

        function createDraggingPiece(e) {
            const existing = document.querySelector('.dragging-piece');
            if (existing) existing.remove();
            
            const pieceEl = createPieceElement(game.draggingPiece);
            pieceEl.className = 'piece dragging-piece';
            
            if (game.isMobile) {
                pieceEl.classList.add('mobile-offset');
            }
            
            pieceEl.style.gridTemplateColumns = `repeat(${game.draggingPiece.shape[0].length}, 24px)`;
            pieceEl.style.left = (e.clientX || e.pageX) + 'px';
            pieceEl.style.top = (e.clientY || e.pageY) + 'px';
            
            document.body.appendChild(pieceEl);
        }

        document.addEventListener('mousemove', (e) => {
            if (game.draggingPiece) {
                const draggingEl = document.querySelector('.dragging-piece');
                if (draggingEl) {
                    draggingEl.style.left = e.clientX + 'px';
                    draggingEl.style.top = e.clientY + 'px';
                }
                showPreview(e.clientX, e.clientY);
            }
        });

        document.addEventListener('touchmove', (e) => {
            if (game.draggingPiece) {
                e.preventDefault();
                const touch = e.touches[0];
                const draggingEl = document.querySelector('.dragging-piece');
                if (draggingEl) {
                    draggingEl.style.left = touch.pageX + 'px';
                    draggingEl.style.top = touch.pageY + 'px';
                }
                showPreview(touch.pageX, touch.pageY);
            }
        }, { passive: false });

        function showPreview(x, y) {
            const gridEl = document.getElementById('grid');
            const rect = gridEl.getBoundingClientRect();
            
            // Nếu là mobile, offset Y lên trên để khớp với vị trí khối gạch hiển thị
            if (game.isMobile) {
                y = y - 80;
            }
            
            if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
                clearPreview();
                return;
            }
            
            const cellSize = rect.width / GRID_SIZE;
            const col = Math.floor((x - rect.left) / cellSize);
            const row = Math.floor((y - rect.top) / cellSize);
            
            clearPreview();
            
            const valid = canPlace(game.draggingPiece.shape, row, col);
            const cells = document.querySelectorAll('.cell');
            
            game.draggingPiece.shape.forEach((shapeRow, r) => {
                shapeRow.forEach((cell, c) => {
                    if (cell) {
                        const gridRow = row + r;
                        const gridCol = col + c;
                        if (gridRow >= 0 && gridRow < GRID_SIZE && gridCol >= 0 && gridCol < GRID_SIZE) {
                            const cellIndex = gridRow * GRID_SIZE + gridCol;
                            cells[cellIndex].classList.add(valid ? 'preview' : 'invalid-preview');
                            if (valid) {
                                cells[cellIndex].style.background = game.draggingPiece.color;
                            }
                        }
                    }
                });
            });

            if (valid) {
                highlightWillClearLines(row, col);
            }
        }

        function highlightWillClearLines(row, col) {
            const tempGrid = game.grid.map(r => [...r]);
            
            game.draggingPiece.shape.forEach((shapeRow, r) => {
                shapeRow.forEach((cell, c) => {
                    if (cell) {
                        const gridRow = row + r;
                        const gridCol = col + c;
                        if (gridRow >= 0 && gridRow < GRID_SIZE && gridCol >= 0 && gridCol < GRID_SIZE) {
                            tempGrid[gridRow][gridCol] = game.draggingPiece.color;
                        }
                    }
                });
            });

            const cells = document.querySelectorAll('.cell');
            
            for (let r = 0; r < GRID_SIZE; r++) {
                if (tempGrid[r].every(cell => cell)) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        cells[r * GRID_SIZE + c].classList.add('will-clear');
                    }
                }
            }
            
            for (let c = 0; c < GRID_SIZE; c++) {
                if (tempGrid.every(row => row[c])) {
                    for (let r = 0; r < GRID_SIZE; r++) {
                        cells[r * GRID_SIZE + c].classList.add('will-clear');
                    }
                }
            }
        }

        function clearPreview() {
            document.querySelectorAll('.cell').forEach(cell => {
                cell.classList.remove('preview', 'invalid-preview', 'will-clear');
            });
            drawGrid();
        }

        document.addEventListener('mouseup', (e) => {
            if (game.draggingPiece) {
                tryPlacePiece(e.clientX, e.clientY);
            }
        });

        document.addEventListener('touchend', (e) => {
            if (game.draggingPiece) {
                const touch = e.changedTouches[0];
                tryPlacePiece(touch.pageX, touch.pageY);
            }
        });

        function tryPlacePiece(x, y) {
            const gridEl = document.getElementById('grid');
            const rect = gridEl.getBoundingClientRect();
            
            // Offset Y cho mobile khi tính vị trí đặt
            if (game.isMobile) {
                y = y - 80;
            }
            
            const cellSize = rect.width / GRID_SIZE;
            const col = Math.floor((x - rect.left) / cellSize);
            const row = Math.floor((y - rect.top) / cellSize);
            
            if (canPlace(game.draggingPiece.shape, row, col)) {
                placePiece(game.draggingPiece, row, col);
                game.pieces.splice(game.draggingIndex, 1);
                
                if (game.pieces.length === 0) {
                    game.pieces = generateSmartPieces();
                }
                
                drawPieces();
                
                if (!hasValidMoves()) {
                    gameOver();
                }
            }
            
            endDrag();
        }

        function endDrag() {
            const draggingEl = document.querySelector('.dragging-piece');
            if (draggingEl) draggingEl.remove();
            
            document.querySelectorAll('.piece-slot').forEach(slot => {
                slot.classList.remove('dragging');
            });
            
            game.draggingPiece = null;
            game.draggingIndex = -1;
            clearPreview();
        }

        function placePiece(piece, row, col) {
            piece.shape.forEach((shapeRow, r) => {
                shapeRow.forEach((cell, c) => {
                    if (cell) {
                        game.grid[row + r][col + c] = piece.color;
                    }
                });
            });
            
            const pieceSize = piece.shape.flat().filter(c => c).length;
            game.score += pieceSize;
            
            checkAndClearLines();
            updateScore();
            drawGrid();
        }

        function checkAndClearLines() {
            const rowsToClear = [];
            const colsToClear = [];
            
            for (let r = 0; r < GRID_SIZE; r++) {
                if (game.grid[r].every(cell => cell)) {
                    rowsToClear.push(r);
                }
            }
            
            for (let c = 0; c < GRID_SIZE; c++) {
                if (game.grid.every(row => row[c])) {
                    colsToClear.push(c);
                }
            }
            
            rowsToClear.forEach(r => {
                game.grid[r] = Array(GRID_SIZE).fill(null);
                game.score += 10;
            });
            
            colsToClear.forEach(c => {
                game.grid.forEach(row => row[c] = null);
                game.score += 10;
            });
            
            const totalCleared = rowsToClear.length + colsToClear.length;
            if (totalCleared > 1) {
                game.score += totalCleared * 5;
                showCombo(totalCleared);
                highlightClearedLines(rowsToClear, colsToClear);
            }
            
            if (game.grid.every(row => row.every(cell => !cell))) {
                game.score += 100;
                showCombo('PERFECT!');
            }
        }

        function highlightClearedLines(rows, cols) {
            const cells = document.querySelectorAll('.cell');
            
            rows.forEach(r => {
                for (let c = 0; c < GRID_SIZE; c++) {
                    cells[r * GRID_SIZE + c].classList.add('highlight');
                }
            });
            
            cols.forEach(c => {
                for (let r = 0; r < GRID_SIZE; r++) {
                    cells[r * GRID_SIZE + c].classList.add('highlight');
                }
            });
            
            setTimeout(() => {
                cells.forEach(cell => cell.classList.remove('highlight'));
            }, 500);
        }

        function showCombo(count) {
            const combo = typeof count === 'number' ? COMBO_MESSAGES[Math.min(count, 6)] : { text: count, color: '#52b788' };
            if (!combo) return;
            
            const effect = document.createElement('div');
            effect.className = 'combo-effect';
            effect.textContent = combo.text;
            effect.style.color = combo.color;
            
            document.body.appendChild(effect);
            
            setTimeout(() => effect.remove(), 1200);
        }

        function hasValidMoves() {
            return canPlayWithPieces(game.pieces, game.grid);
        }

        function gameOver() {
            document.getElementById('finalScore').textContent = game.score;
            document.getElementById('gameOverOverlay').classList.add('show');
        }

        function updateScore() {
            document.getElementById('score').textContent = game.score;
            if (game.score > game.highest) {
                game.highest = game.score;
                document.getElementById('highest').textContent = game.highest;
            }
        }

        function restartGame() {
            game.grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
            game.score = 0;
            game.pieces = generateSmartPieces();
            game.draggingPiece = null;
            game.draggingIndex = -1;
            
            document.getElementById('gameOverOverlay').classList.remove('show');
            
            updateScore();
            drawGrid();
            drawPieces();
        }

        initGrid();
        game.pieces = generateSmartPieces();
        drawGrid();
        drawPieces();
        updateScore();
    </script>
</body>
</html>
