# =====================================================
# Block Blast Game - ESP32 ILI9341 Parallel Version
# Using HughMaingauche's Python Parallel Driver
# =====================================================

from machine import Pin, SPI
import ILI9341       # Parallel display driver (includes char methods)
import xpt2046       # Touch driver
import time
import urandom as random

# =====================================================
# HARDWARE CONFIGURATION
# =====================================================

# Display Pins - Parallel 8-bit Interface
PIN_D0 = 12
PIN_D1 = 13
PIN_D2 = 26
PIN_D3 = 25
PIN_D4 = 17
PIN_D5 = 16
PIN_D6 = 27
PIN_D7 = 14

# Display Control Pins
PIN_LCD_CS = 33   # Chip Select
PIN_LCD_RS = 32   # Register Select (DC)
PIN_LCD_WR = 4    # Write
PIN_LCD_RD = 2    # Read
PIN_LCD_RST = 22  # Reset
PIN_LCD_BL = 21   # Backlight (connect to 3V3 for max brightness)

# Touch Pins - SPI Interface
PIN_T_SCK = 18
PIN_T_MOSI = 23
PIN_T_MISO = 19
PIN_T_CS = 5
PIN_T_IRQ = 34    # Touch interrupt (GPIO 34 - input only, safer than 35)

# Display Settings
SCREEN_WIDTH = 320
SCREEN_HEIGHT = 240

# Game Settings
GRID_SIZE = 6
CELL_SIZE = 28
GRID_X = 50
GRID_Y = 45

PIECE_PREVIEW_Y = 190
PIECE_PREVIEW_SPACING = 80
PIECE_BOX_SIZE = 60
PIECE_PREVIEW_X_START = 30  # Starting X position for pieces
PIECE_CELL_SIZE = 12        # Size of each cell in piece preview

# Colors (RGB565 format - 16-bit hex)
COLOR_WHITE = 0xFFFF
COLOR_BLACK = 0x0000
COLOR_GRAY = 0xCE79
COLOR_DARK_GRAY = 0x632C
COLOR_BG = 0xF7BE          # Light background
COLOR_GRID_BG = 0xDEFB     # Grid background
COLOR_HIGHLIGHT = 0x67E0   # Green highlight
COLOR_TEXT = 0x0000
COLOR_RED = 0xF800

# Block Colors (RGB565)
BLOCK_COLORS = [
    0xFD2D,  # Red
    0x07FF,  # Cyan
    0xFFE0,  # Yellow
    0x07E0,  # Green
    0xF81F,  # Magenta
    0x001F,  # Blue
    0xFDA0,  # Orange
    0xFE19,  # Pink
]

# =====================================================
# BLOCK SHAPES
# =====================================================

SHAPES_EASY = [
    [[1]],
    [[1, 1]],
    [[1], [1]],
]

SHAPES_MEDIUM = [
    [[1, 1], [1, 1]],
    [[1, 1, 1]],
    [[1], [1], [1]],
    [[1, 0], [1, 1]],
    [[0, 1], [1, 1]],
    [[1, 1], [1, 0]],
    [[1, 1], [0, 1]],
]

SHAPES_HARD = [
    [[1, 1, 1, 1]],
    [[1], [1], [1], [1]],
    [[1, 1, 1], [1, 0, 0]],
    [[1, 1, 1], [0, 0, 1]],
    [[1, 0, 0], [1, 1, 1]],
    [[0, 0, 1], [1, 1, 1]],
    [[1, 1, 0], [0, 1, 1]],
    [[0, 1, 1], [1, 1, 0]],
]

ALL_SHAPES = SHAPES_EASY + SHAPES_MEDIUM + SHAPES_HARD

# =====================================================
# GAME CLASS
# =====================================================

class BlockBlastGame:
    def __init__(self):
        print("Initializing Block Blast (Parallel Version)...")
        
        # Initialize Parallel Display - FIX: Pass GPIO numbers, not Pin objects
        self.display = ILI9341.screen(
            PIN_LCD_RD,   # Pass GPIO number (2)
            PIN_LCD_WR,   # Pass GPIO number (4)
            PIN_LCD_RS,   # Pass GPIO number (32)
            PIN_LCD_CS,   # Pass GPIO number (33)
            PIN_LCD_RST,  # Pass GPIO number (22)
            PIN_D0, PIN_D1, PIN_D2, PIN_D3,
            PIN_D4, PIN_D5, PIN_D6, PIN_D7
        )
        self.display.begin()
        
        # Font methods are already imported in ILI9341.screen class
        # No need to create separate font object
        print("Display initialized (Parallel 8-bit)")
        
        # Initialize Touch (SPI)
        self.spi_touch = SPI(
            2,  # HSPI bus
            baudrate=2000000,
            sck=Pin(PIN_T_SCK),
            mosi=Pin(PIN_T_MOSI),
            miso=Pin(PIN_T_MISO)
        )
        
        self.touch = xpt2046.Touch(
            spi=self.spi_touch,
            cs=Pin(PIN_T_CS),
            int_pin=Pin(PIN_T_IRQ),
            int_handler=self.touch_handler
        )
        
        print("Touch initialized (SPI)")
        
        # Touch state
        self.touch_x = 0
        self.touch_y = 0
        self.touch_pressed = False
        self.last_touch_time = 0
        
        # Game state
        self.grid = [[0 for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
        self.score = 0
        self.pieces = []
        self.selected_piece = -1
        self.game_over = False
        
        # Generate initial pieces
        self.generate_pieces()
        
        # Draw initial screen
        self.draw_all()
        
        print("Initialization complete!")
    
    def touch_handler(self, x, y):
        """Interrupt handler for touch events"""
        self.touch_x = x
        self.touch_y = y
        self.touch_pressed = True
    
    def generate_pieces(self):
        """Generate 3 random pieces"""
        self.pieces = []
        for _ in range(3):
            shape = random.choice(ALL_SHAPES)
            color_idx = random.randint(0, len(BLOCK_COLORS) - 1)
            self.pieces.append({
                'shape': shape,
                'color': BLOCK_COLORS[color_idx],
                'placed': False
            })
    
    def can_place(self, shape, row, col):
        """Check if piece can be placed at position"""
        for r in range(len(shape)):
            for c in range(len(shape[0])):
                if shape[r][c]:
                    grid_r = row + r
                    grid_c = col + c
                    if (grid_r < 0 or grid_r >= GRID_SIZE or 
                        grid_c < 0 or grid_c >= GRID_SIZE or
                        self.grid[grid_r][grid_c] != 0):
                        return False
        return True
    
    def place_piece(self, shape, color, row, col):
        """Place piece on grid"""
        for r in range(len(shape)):
            for c in range(len(shape[0])):
                if shape[r][c]:
                    self.grid[row + r][col + c] = color
    
    def check_lines(self):
        """Check and clear complete lines"""
        lines_cleared = 0
        
        # Check rows
        rows_to_clear = []
        for r in range(GRID_SIZE):
            if all(self.grid[r][c] != 0 for c in range(GRID_SIZE)):
                rows_to_clear.append(r)
        
        # Check columns
        cols_to_clear = []
        for c in range(GRID_SIZE):
            if all(self.grid[r][c] != 0 for r in range(GRID_SIZE)):
                cols_to_clear.append(c)
        
        # Highlight lines to clear
        if rows_to_clear or cols_to_clear:
            for r in rows_to_clear:
                for c in range(GRID_SIZE):
                    x = GRID_X + c * CELL_SIZE
                    y = GRID_Y + r * CELL_SIZE
                    self.display.fillRect(
                        x + 1, y + 1, 
                        CELL_SIZE - 2, CELL_SIZE - 2, 
                        COLOR_HIGHLIGHT
                    )
            
            for c in cols_to_clear:
                for r in range(GRID_SIZE):
                    x = GRID_X + c * CELL_SIZE
                    y = GRID_Y + r * CELL_SIZE
                    self.display.fillRect(
                        x + 1, y + 1,
                        CELL_SIZE - 2, CELL_SIZE - 2,
                        COLOR_HIGHLIGHT
                    )
            
            time.sleep_ms(200)  # Show highlight effect
        
        # Clear the lines
        for r in rows_to_clear:
            for c in range(GRID_SIZE):
                self.grid[r][c] = 0
            lines_cleared += 1
        
        for c in cols_to_clear:
            for r in range(GRID_SIZE):
                self.grid[r][c] = 0
            lines_cleared += 1
        
        return lines_cleared
    
    def check_game_over(self):
        """Check if any piece can be placed"""
        for piece in self.pieces:
            if not piece['placed']:
                shape = piece['shape']
                for r in range(GRID_SIZE):
                    for c in range(GRID_SIZE):
                        if self.can_place(shape, r, c):
                            return False
        return True
    
    def handle_touch(self, x, y):
        """Handle touch input"""
        # Check if touched a piece
        for i, piece in enumerate(self.pieces):
            if piece['placed']:
                continue
            
            px = PIECE_PREVIEW_X_START + i * PIECE_PREVIEW_SPACING
            py = PIECE_PREVIEW_Y
            
            if px <= x <= px + PIECE_BOX_SIZE and py <= y <= py + PIECE_BOX_SIZE:
                self.selected_piece = i
                self.draw_all()
                return
        
        # Check if touched grid
        if self.selected_piece >= 0:
            if GRID_X <= x <= GRID_X + GRID_SIZE * CELL_SIZE and \
               GRID_Y <= y <= GRID_Y + GRID_SIZE * CELL_SIZE:
                
                col = (x - GRID_X) // CELL_SIZE
                row = (y - GRID_Y) // CELL_SIZE
                
                piece = self.pieces[self.selected_piece]
                shape = piece['shape']
                color = piece['color']
                
                if self.can_place(shape, row, col):
                    # Place the piece
                    self.place_piece(shape, color, row, col)
                    piece['placed'] = True
                    self.selected_piece = -1
                    
                    # Check and clear lines
                    lines = self.check_lines()
                    if lines > 0:
                        self.score += lines * 10
                    
                    # Check if all pieces placed
                    if all(p['placed'] for p in self.pieces):
                        self.generate_pieces()
                    
                    # Check game over
                    if self.check_game_over():
                        self.game_over = True
                    
                    # Redraw everything
                    self.draw_all()
    
    def draw_all(self):
        """Draw entire screen"""
        # Clear screen
        self.display.fillscreen(COLOR_BG)
        
        # Draw title and score
        self.display.prints(10, 10, "BLOCK BLAST", COLOR_TEXT, COLOR_BG, 1)
        self.display.prints(200, 10, "Score: " + str(self.score), COLOR_TEXT, COLOR_BG, 1)
        
        # Draw grid
        self.draw_grid()
        
        # Draw pieces
        self.draw_pieces()
        
        # Draw game over
        if self.game_over:
            self.display.prints(80, 110, "GAME OVER!", COLOR_RED, COLOR_BG, 2)
            self.display.prints(60, 140, "Tap to restart", COLOR_TEXT, COLOR_BG, 1)
    
    def draw_grid(self):
        """Draw game grid"""
        for r in range(GRID_SIZE):
            for c in range(GRID_SIZE):
                x = GRID_X + c * CELL_SIZE
                y = GRID_Y + r * CELL_SIZE
                
                # Determine cell color
                if self.grid[r][c] != 0:
                    color = self.grid[r][c]
                else:
                    color = COLOR_WHITE
                
                # Draw filled cell
                self.display.fillRect(x + 1, y + 1, CELL_SIZE - 2, CELL_SIZE - 2, color)
                
                # Draw border
                self.display.drawLine(x, y, x + CELL_SIZE, y, COLOR_GRAY)
                self.display.drawLine(x, y, x, y + CELL_SIZE, COLOR_GRAY)
                self.display.drawLine(x + CELL_SIZE, y, x + CELL_SIZE, y + CELL_SIZE, COLOR_GRAY)
                self.display.drawLine(x, y + CELL_SIZE, x + CELL_SIZE, y + CELL_SIZE, COLOR_GRAY)
    
    def draw_pieces(self):
        """Draw piece previews"""
        for i, piece in enumerate(self.pieces):
            if piece['placed']:
                continue
            
            x = PIECE_PREVIEW_X_START + i * PIECE_PREVIEW_SPACING
            y = PIECE_PREVIEW_Y
            
            # Draw selection highlight
            if i == self.selected_piece:
                self.display.drawLine(x - 2, y - 2, x + PIECE_BOX_SIZE + 2, y - 2, COLOR_HIGHLIGHT)
                self.display.drawLine(x - 2, y - 2, x - 2, y + PIECE_BOX_SIZE + 2, COLOR_HIGHLIGHT)
                self.display.drawLine(x + PIECE_BOX_SIZE + 2, y - 2, x + PIECE_BOX_SIZE + 2, y + PIECE_BOX_SIZE + 2, COLOR_HIGHLIGHT)
                self.display.drawLine(x - 2, y + PIECE_BOX_SIZE + 2, x + PIECE_BOX_SIZE + 2, y + PIECE_BOX_SIZE + 2, COLOR_HIGHLIGHT)
            
            # Draw box background
            self.display.fillRect(x, y, PIECE_BOX_SIZE, PIECE_BOX_SIZE, COLOR_WHITE)
            
            # Draw box border
            self.display.drawLine(x, y, x + PIECE_BOX_SIZE, y, COLOR_GRAY)
            self.display.drawLine(x, y, x, y + PIECE_BOX_SIZE, COLOR_GRAY)
            self.display.drawLine(x + PIECE_BOX_SIZE, y, x + PIECE_BOX_SIZE, y + PIECE_BOX_SIZE, COLOR_GRAY)
            self.display.drawLine(x, y + PIECE_BOX_SIZE, x + PIECE_BOX_SIZE, y + PIECE_BOX_SIZE, COLOR_GRAY)
            
            # Draw shape
            shape = piece['shape']
            color = piece['color']
            
            # Center the shape
            shape_h = len(shape)
            shape_w = len(shape[0])
            offset_x = (PIECE_BOX_SIZE - shape_w * PIECE_CELL_SIZE) // 2
            offset_y = (PIECE_BOX_SIZE - shape_h * PIECE_CELL_SIZE) // 2
            
            for r in range(shape_h):
                for c in range(shape_w):
                    if shape[r][c]:
                        bx = x + offset_x + c * PIECE_CELL_SIZE
                        by = y + offset_y + r * PIECE_CELL_SIZE
                        self.display.fillRect(bx, by, PIECE_CELL_SIZE - 2, PIECE_CELL_SIZE - 2, color)
    
    def reset_game(self):
        """Reset game to initial state"""
        self.grid = [[0 for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
        self.score = 0
        self.selected_piece = -1
        self.game_over = False
        self.generate_pieces()
        self.draw_all()
    
    def run(self):
        """Main game loop"""
        print("Game started!")
        last_touch_state = False
        
        while True:
            # Check touch state
            current_time = time.ticks_ms()
            
            if self.touch_pressed:
                # Debounce - only process if enough time passed
                if time.ticks_diff(current_time, self.last_touch_time) > 200:
                    if not last_touch_state:  # New touch
                        print(f"Touch at: {self.touch_x}, {self.touch_y}")
                        
                        if self.game_over:
                            # Reset game on touch when game over
                            self.reset_game()
                        else:
                            # Handle normal touch
                            self.handle_touch(self.touch_x, self.touch_y)
                        
                        self.last_touch_time = current_time
                        last_touch_state = True
                
                self.touch_pressed = False
            else:
                last_touch_state = False
            
            time.sleep_ms(50)

# =====================================================
# MAIN ENTRY POINT
# =====================================================

def main():
    """Main entry point"""
    print("=" * 40)
    print("BLOCK BLAST for ESP32")
    print("Parallel 8-bit Interface")
    print("=" * 40)
    
    try:
        game = BlockBlastGame()
        game.run()
    except KeyboardInterrupt:
        print("\nGame stopped by user")
    except Exception as e:
        print(f"Error: {e}")
        import sys
        sys.print_exception(e)

if __name__ == "__main__":
    main()
