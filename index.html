<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Block Blast - Minimalist</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 15px;
            color: #999;
            touch-action: pan-y;
        }

        .game-container {
            background: #111;
            border-radius: 20px;
            padding: 30px;
            max-width: 480px;
            width: 100%;
            border: 1px solid #1a1a1a;
        }

        .header {
            text-align: center;
            margin-bottom: 25px;
        }

        .title {
            font-size: 14px;
            font-weight: 400;
            color: #666;
            margin-bottom: 20px;
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        .scores {
            display: flex;
            justify-content: center;
            gap: 40px;
        }

        .score-box {
            text-align: center;
        }

        .score-label {
            font-size: 10px;
            color: #444;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 8px;
        }

        .score-value {
            font-size: 28px;
            font-weight: 300;
            color: #fff;
            font-variant-numeric: tabular-nums;
        }

        .grid-container {
            background: #0a0a0a;
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 25px;
            border: 1px solid #1a1a1a;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
            margin: 0 auto;
            max-width: 400px;
        }

        .cell {
            aspect-ratio: 1;
            background: #151515;
            border-radius: 4px;
            transition: all 0.15s ease;
            border: 1px solid transparent;
        }

        .cell.filled {
            border-color: rgba(255, 255, 255, 0.1);
        }

        .cell.preview {
            opacity: 0.5;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .cell.invalid-preview {
            opacity: 0.3;
            background: #2a1515 !important;
            border: 1px solid rgba(255, 100, 100, 0.2);
        }

        .cell.will-clear {
            animation: willClearMinimal 1s ease-in-out infinite;
        }

        @keyframes willClearMinimal {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .cell.highlight {
            animation: pulseMinimal 0.4s ease-out;
        }

        @keyframes pulseMinimal {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }

        .cell.clearing {
            animation: clearEffect 0.6s ease-out forwards;
        }

        @keyframes clearEffect {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            40% {
                transform: scale(1.2);
                opacity: 0.8;
                filter: brightness(1.5);
            }
            70% {
                transform: scale(0.8);
                opacity: 0.4;
            }
            100% {
                transform: scale(0);
                opacity: 0;
            }
        }

        .pieces-container {
            display: flex;
            justify-content: space-around;
            gap: 12px;
            margin-bottom: 25px;
        }

        .piece-slot {
            background: #0a0a0a;
            border-radius: 12px;
            padding: 20px;
            min-width: 90px;
            min-height: 90px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            transition: all 0.2s ease;
            border: 1px solid #1a1a1a;
            flex: 1;
        }

        .piece-slot:active {
            transform: scale(0.95);
        }

        .piece-slot.dragging {
            opacity: 0.2;
        }

        .piece {
            display: grid;
            gap: 3px;
            pointer-events: none;
        }

        .piece-cell {
            width: 18px;
            height: 18px;
            border-radius: 3px;
            transition: all 0.15s ease;
        }

        .dragging-piece {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            transform: translate(-50%, -50%);
            opacity: 0.9;
            transition: none;
        }

        .dragging-piece.lifted {
            transform: translate(-50%, calc(-50% - 120px)) scale(1.15);
        }

        .dragging-piece .piece-cell {
            width: 22px;
            height: 22px;
        }

        .controls {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .btn {
            background: #1a1a1a;
            color: #999;
            border: 1px solid #222;
            padding: 12px 28px;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 400;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .btn:hover {
            background: #222;
            color: #ccc;
            border-color: #2a2a2a;
        }

        .btn:active {
            transform: scale(0.97);
        }

        .game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            animation: fadeIn 0.2s ease;
        }

        .game-over-overlay.show {
            display: flex;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .game-over-content {
            background: #111;
            padding: 50px;
            border-radius: 20px;
            text-align: center;
            border: 1px solid #1a1a1a;
        }

        .game-over-title {
            font-size: 16px;
            font-weight: 400;
            color: #666;
            margin-bottom: 30px;
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        .final-score {
            font-size: 48px;
            font-weight: 200;
            color: #fff;
            margin-bottom: 40px;
            font-variant-numeric: tabular-nums;
        }

        .combo-effect {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            font-weight: 300;
            color: #fff;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 40px;
            border-radius: 12px;
            pointer-events: none;
            animation: comboMinimal 1s ease-out forwards;
            z-index: 2000;
            letter-spacing: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        @keyframes comboMinimal {
            0% {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0;
            }
            20% {
                opacity: 1;
            }
            80% {
                opacity: 1;
                transform: translate(-50%, -60%) scale(1);
            }
            100% {
                transform: translate(-50%, -70%) scale(1);
                opacity: 0;
            }
        }

        .author {
            text-align: center;
            color: #333;
            font-size: 9px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        /* Vibrant color palette - Brighter version */
        .color-1 { background: #4a7a9e; }
        .color-2 { background: #5a9e7a; }
        .color-3 { background: #9e7a5a; }
        .color-4 { background: #7a5a9e; }
        .color-5 { background: #9e5a7a; }
        .color-6 { background: #5a7a9e; }
        .color-7 { background: #7a9e5a; }

        @media (max-width: 480px) {
            .game-container {
                padding: 20px;
            }

            .piece-cell {
                width: 16px;
                height: 16px;
            }

            .dragging-piece .piece-cell {
                width: 20px;
                height: 20px;
            }

            .dragging-piece.lifted {
                transform: translate(-50%, calc(-50% - 100px)) scale(1.1);
            }
        }

        /* Touch feedback */
        @media (hover: none) {
            .piece-slot:active {
                background: #151515;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <div class="title">Block Blast</div>
            <div class="scores">
                <div class="score-box">
                    <div class="score-label">Best</div>
                    <div class="score-value" id="highest">0</div>
                </div>
                <div class="score-box">
                    <div class="score-label">Score</div>
                    <div class="score-value" id="score">0</div>
                </div>
            </div>
        </div>

        <div class="grid-container">
            <div class="grid" id="grid"></div>
        </div>

        <div class="pieces-container" id="pieces"></div>

        <div class="controls">
            <button class="btn" onclick="restartGame()">New Game</button>
        </div>

        <div class="author">
            Author: Duc Thien khong biet code HTML ^^
        </div>
    </div>


    <div class="game-over-overlay" id="gameOverOverlay">
        <div class="game-over-content">
            <div class="game-over-title">Game Over</div>
            <div class="final-score" id="finalScore">0</div>
            <button class="btn" onclick="restartGame()">Play Again</button>
        </div>
    </div>

    <script>
        const GRID_SIZE = 8;
        const MINIMALIST_COLORS = [
            '#4a7a9e', // Bright blue-grey
            '#5a9e7a', // Bright green-grey
            '#9e7a5a', // Bright brown-grey
            '#7a5a9e', // Bright purple-grey
            '#9e5a7a', // Bright rose-grey
            '#5a7a9e', // Bright steel-grey
            '#7a9e5a'  // Bright olive-grey
        ];

        const SHAPES = {
            easy: [
                [[1]],
                [[1, 1]],
                [[1], [1]]
            ],
            medium: [
                [[1, 1, 1]],
                [[1], [1], [1]],
                [[1, 1], [1, 1]],
                [[1, 0], [1, 1]],
                [[1, 1], [1, 0]],
                [[1, 1], [0, 1]],
                [[1, 1, 1], [1, 0, 0]],
                [[1, 0, 0], [1, 1, 1]],
                [[1, 1, 1], [0, 0, 1]],
                [[0, 1], [0, 1], [1, 1]],
                [[1, 0], [1, 0], [1, 1]],
                [[1, 1], [1, 0], [1, 0]],
            ],
            hard: [
                [[1, 1, 1, 1]],
                [[1], [1], [1], [1]],
                [[1, 1, 1], [0, 1, 0]],
                [[0, 1, 0], [1, 1, 1]],
                [[0, 1], [1, 1], [0, 1]],
                [[1, 1, 0], [0, 1, 1]],
                [[0, 1, 1], [1, 1, 0]],
                [[1, 0], [1, 1], [0, 1]],
                [[0, 1], [1, 1], [1, 0]],
                [[1, 1, 1], [1, 1, 1]],
                [[1, 1], [1, 1], [1, 1]],
                [[1, 1, 1], [1, 0, 0], [1, 0, 0]],
                [[1, 1, 1], [0, 0, 1], [0, 0, 1]],
                [[1, 1, 1, 1, 1]],
                [[1], [1], [1], [1], [1]],
                [[1, 0], [0, 1]],
                [[0, 1], [1, 0]],
                [[1, 1, 1], [1, 1, 1], [1, 1, 1]],
            ]
        };

        const COMBO_MESSAGES = {
            2: 'NICE',
            3: 'GREAT',
            4: 'EXCELLENT',
            5: 'AMAZING',
            6: 'INCREDIBLE'
        };

        let game = {
            grid: Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null)),
            score: 0,
            highest: 0,
            pieces: [],
            draggingPiece: null,
            draggingIndex: -1,
            dragStartPos: null,
            pieceOffset: null,
            isMobile: false
        };

        function detectMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
                || ('ontouchstart' in window);
        }

        game.isMobile = detectMobile();

        function initGrid() {
            const gridEl = document.getElementById('grid');
            gridEl.innerHTML = '';
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.index = i;
                gridEl.appendChild(cell);
            }
        }

        function drawGrid() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach((cell, i) => {
                const row = Math.floor(i / GRID_SIZE);
                const col = i % GRID_SIZE;
                const value = game.grid[row][col];
                
                if (value) {
                    cell.style.background = value;
                    cell.classList.add('filled');
                } else {
                    cell.style.background = '#151515';
                    cell.classList.remove('filled');
                }
                cell.classList.remove('preview', 'invalid-preview', 'highlight');
            });
        }

        function canPlace(shape, row, col) {
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        const newR = row + r;
                        const newC = col + c;
                        if (newR < 0 || newR >= GRID_SIZE || newC < 0 || newC >= GRID_SIZE) {
                            return false;
                        }
                        if (game.grid[newR][newC]) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function canPlayWithPieces(pieces, grid) {
            for (let piece of pieces) {
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        if (canPlaceOnGrid(piece.shape, row, col, grid)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function canPlaceOnGrid(shape, row, col, grid) {
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        const newR = row + r;
                        const newC = col + c;
                        if (newR < 0 || newR >= GRID_SIZE || newC < 0 || newC >= GRID_SIZE) {
                            return false;
                        }
                        if (grid[newR][newC]) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function generateSmartPieces() {
            const maxAttempts = 50;
            let attempts = 0;
            
            while (attempts < maxAttempts) {
                attempts++;
                const pieces = [];
                
                for (let i = 0; i < 3; i++) {
                    const rand = Math.random();
                    let difficulty;
                    if (rand < 0.15) {
                        difficulty = 'easy';
                    } else if (rand < 0.50) {
                        difficulty = 'medium';
                    } else {
                        difficulty = 'hard';
                    }
                    
                    const shapeList = SHAPES[difficulty];
                    const shape = shapeList[Math.floor(Math.random() * shapeList.length)];
                    const color = MINIMALIST_COLORS[Math.floor(Math.random() * MINIMALIST_COLORS.length)];
                    
                    pieces.push({ shape: JSON.parse(JSON.stringify(shape)), color, difficulty });
                }
                
                if (canPlayWithPieces(pieces, game.grid)) {
                    return pieces;
                }
            }
            
            return [
                { shape: [[1]], color: MINIMALIST_COLORS[0], difficulty: 'easy' },
                { shape: [[1, 1]], color: MINIMALIST_COLORS[1], difficulty: 'easy' },
                { shape: [[1], [1]], color: MINIMALIST_COLORS[2], difficulty: 'easy' }
            ];
        }

        function drawPieces() {
            const container = document.getElementById('pieces');
            container.innerHTML = '';
            
            game.pieces.forEach((piece, index) => {
                const slot = document.createElement('div');
                slot.className = 'piece-slot';
                slot.dataset.index = index;
                
                const pieceEl = createPieceElement(piece);
                slot.appendChild(pieceEl);
                
                slot.addEventListener('mousedown', (e) => startDrag(e, index));
                slot.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startDrag(e.touches[0], index);
                }, { passive: false });
                
                container.appendChild(slot);
            });
        }

        function createPieceElement(piece) {
            const pieceEl = document.createElement('div');
            pieceEl.className = 'piece';
            pieceEl.style.gridTemplateColumns = `repeat(${piece.shape[0].length}, 1fr)`;
            
            piece.shape.forEach(row => {
                row.forEach(cell => {
                    const cellEl = document.createElement('div');
                    cellEl.className = 'piece-cell';
                    if (cell) {
                        cellEl.classList.add('filled');
                        cellEl.style.background = piece.color;
                    } else {
                        cellEl.style.background = 'transparent';
                    }
                    pieceEl.appendChild(cellEl);
                });
            });
            
            return pieceEl;
        }

        function getPieceCenter(shape) {
            let minRow = shape.length, maxRow = -1;
            let minCol = shape[0].length, maxCol = -1;
            
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        minRow = Math.min(minRow, r);
                        maxRow = Math.max(maxRow, r);
                        minCol = Math.min(minCol, c);
                        maxCol = Math.max(maxCol, c);
                    }
                }
            }
            
            return {
                row: (minRow + maxRow) / 2,
                col: (minCol + maxCol) / 2
            };
        }

        function startDrag(e, index) {
            game.draggingIndex = index;
            game.draggingPiece = game.pieces[index];
            
            const center = getPieceCenter(game.draggingPiece.shape);
            game.pieceOffset = center;
            
            const slots = document.querySelectorAll('.piece-slot');
            slots[index].classList.add('dragging');
            
            createDraggingPiece(e);
        }

        function createDraggingPiece(e) {
            const existing = document.querySelector('.dragging-piece');
            if (existing) existing.remove();
            
            const pieceEl = createPieceElement(game.draggingPiece);
            pieceEl.className = 'piece dragging-piece lifted';
            pieceEl.style.gridTemplateColumns = `repeat(${game.draggingPiece.shape[0].length}, 1fr)`;
            pieceEl.style.left = (e.clientX || e.pageX) + 'px';
            pieceEl.style.top = (e.clientY || e.pageY) + 'px';
            
            document.body.appendChild(pieceEl);
        }

        document.addEventListener('mousemove', (e) => {
            if (game.draggingPiece) {
                const draggingEl = document.querySelector('.dragging-piece');
                if (draggingEl) {
                    draggingEl.style.left = e.clientX + 'px';
                    draggingEl.style.top = e.clientY + 'px';
                }
                showPreview(e.clientX, e.clientY);
            }
        });

        document.addEventListener('touchmove', (e) => {
            if (game.draggingPiece) {
                e.preventDefault();
                const touch = e.touches[0];
                const draggingEl = document.querySelector('.dragging-piece');
                if (draggingEl) {
                    draggingEl.style.left = touch.pageX + 'px';
                    draggingEl.style.top = touch.pageY + 'px';
                }
                showPreview(touch.pageX, touch.pageY);
            }
        }, { passive: false });

        function showPreview(x, y) {
            const gridEl = document.getElementById('grid');
            const rect = gridEl.getBoundingClientRect();
            
            // Điều chỉnh Y dựa trên vị trí khối đã lift lên
            const adjustedY = game.isMobile ? y - 120 : y - 120;
            
            if (x < rect.left || x > rect.right || adjustedY < rect.top || adjustedY > rect.bottom) {
                clearPreview();
                return;
            }
            
            const cellSize = rect.width / GRID_SIZE;
            
            // Tính toán vị trí dựa trên tâm của khối gạch
            const centerOffset = game.pieceOffset;
            const adjustedX = x - (centerOffset.col * cellSize);
            const finalY = adjustedY - (centerOffset.row * cellSize);
            
            const col = Math.round((adjustedX - rect.left) / cellSize);
            const row = Math.round((finalY - rect.top) / cellSize);
            
            clearPreview();
            
            const valid = canPlace(game.draggingPiece.shape, row, col);
            const cells = document.querySelectorAll('.cell');
            
            game.draggingPiece.shape.forEach((shapeRow, r) => {
                shapeRow.forEach((cell, c) => {
                    if (cell) {
                        const gridRow = row + r;
                        const gridCol = col + c;
                        if (gridRow >= 0 && gridRow < GRID_SIZE && gridCol >= 0 && gridCol < GRID_SIZE) {
                            const cellIndex = gridRow * GRID_SIZE + gridCol;
                            cells[cellIndex].classList.add(valid ? 'preview' : 'invalid-preview');
                            if (valid) {
                                cells[cellIndex].style.background = game.draggingPiece.color;
                            }
                        }
                    }
                });
            });

            if (valid) {
                highlightWillClearLines(row, col);
            }
            
            game.currentPreviewPos = { row, col, valid };
        }

        function highlightWillClearLines(row, col) {
            const tempGrid = game.grid.map(r => [...r]);
            
            game.draggingPiece.shape.forEach((shapeRow, r) => {
                shapeRow.forEach((cell, c) => {
                    if (cell) {
                        const gridRow = row + r;
                        const gridCol = col + c;
                        if (gridRow >= 0 && gridRow < GRID_SIZE && gridCol >= 0 && gridCol < GRID_SIZE) {
                            tempGrid[gridRow][gridCol] = game.draggingPiece.color;
                        }
                    }
                });
            });

            const cells = document.querySelectorAll('.cell');
            
            for (let r = 0; r < GRID_SIZE; r++) {
                if (tempGrid[r].every(cell => cell)) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        cells[r * GRID_SIZE + c].classList.add('will-clear');
                    }
                }
            }
            
            for (let c = 0; c < GRID_SIZE; c++) {
                if (tempGrid.every(row => row[c])) {
                    for (let r = 0; r < GRID_SIZE; r++) {
                        cells[r * GRID_SIZE + c].classList.add('will-clear');
                    }
                }
            }
        }

        function clearPreview() {
            document.querySelectorAll('.cell').forEach(cell => {
                cell.classList.remove('preview', 'invalid-preview', 'will-clear');
            });
            drawGrid();
        }

        document.addEventListener('mouseup', (e) => {
            if (game.draggingPiece) {
                tryPlacePiece();
            }
        });

        document.addEventListener('touchend', (e) => {
            if (game.draggingPiece) {
                tryPlacePiece();
            }
        });

        function tryPlacePiece() {
            if (game.currentPreviewPos && game.currentPreviewPos.valid) {
                const { row, col } = game.currentPreviewPos;
                placePiece(game.draggingPiece, row, col);
                game.pieces.splice(game.draggingIndex, 1);
                
                if (game.pieces.length === 0) {
                    game.pieces = generateSmartPieces();
                }
                
                drawPieces();
                
                if (!hasValidMoves()) {
                    gameOver();
                }
            }
            
            endDrag();
        }

        function endDrag() {
            const draggingEl = document.querySelector('.dragging-piece');
            if (draggingEl) draggingEl.remove();
            
            document.querySelectorAll('.piece-slot').forEach(slot => {
                slot.classList.remove('dragging');
            });
            
            game.draggingPiece = null;
            game.draggingIndex = -1;
            game.currentPreviewPos = null;
            clearPreview();
        }

        function placePiece(piece, row, col) {
            piece.shape.forEach((shapeRow, r) => {
                shapeRow.forEach((cell, c) => {
                    if (cell) {
                        game.grid[row + r][col + c] = piece.color;
                    }
                });
            });
            
            const pieceSize = piece.shape.flat().filter(c => c).length;
            game.score += pieceSize;
            
            checkAndClearLines();
            updateScore();
            drawGrid();
        }

        function checkAndClearLines() {
            const rowsToClear = [];
            const colsToClear = [];
            
            for (let r = 0; r < GRID_SIZE; r++) {
                if (game.grid[r].every(cell => cell)) {
                    rowsToClear.push(r);
                }
            }
            
            for (let c = 0; c < GRID_SIZE; c++) {
                if (game.grid.every(row => row[c])) {
                    colsToClear.push(c);
                }
            }
            
            if (rowsToClear.length > 0 || colsToClear.length > 0) {
                // Show clearing animation
                animateClearLines(rowsToClear, colsToClear, () => {
                    // After animation, clear the data
                    rowsToClear.forEach(r => {
                        game.grid[r] = Array(GRID_SIZE).fill(null);
                        game.score += 10;
                    });
                    
                    colsToClear.forEach(c => {
                        game.grid.forEach(row => row[c] = null);
                        game.score += 10;
                    });
                    
                    const totalCleared = rowsToClear.length + colsToClear.length;
                    if (totalCleared > 1) {
                        game.score += totalCleared * 5;
                        showCombo(totalCleared);
                    }
                    
                    if (game.grid.every(row => row.every(cell => !cell))) {
                        game.score += 100;
                        showCombo('PERFECT');
                    }
                    
                    updateScore();
                    drawGrid();
                });
            } else {
                updateScore();
                drawGrid();
            }
        }

        function animateClearLines(rows, cols, callback) {
            const cells = document.querySelectorAll('.cell');
            const cellsToAnimate = new Set();
            
            // Collect all cells to animate
            rows.forEach(r => {
                for (let c = 0; c < GRID_SIZE; c++) {
                    cellsToAnimate.add(r * GRID_SIZE + c);
                }
            });
            
            cols.forEach(c => {
                for (let r = 0; r < GRID_SIZE; r++) {
                    cellsToAnimate.add(r * GRID_SIZE + c);
                }
            });
            
            // Add clearing class with stagger effect
            let delay = 0;
            cellsToAnimate.forEach(index => {
                setTimeout(() => {
                    cells[index].classList.add('clearing');
                }, delay);
                delay += 20; // 20ms stagger between cells
            });
            
            // Wait for animation to complete, then callback
            setTimeout(() => {
                cellsToAnimate.forEach(index => {
                    cells[index].classList.remove('clearing');
                });
                callback();
            }, 600 + (cellsToAnimate.size * 20));
        }

        function highlightClearedLines(rows, cols) {
            const cells = document.querySelectorAll('.cell');
            
            rows.forEach(r => {
                for (let c = 0; c < GRID_SIZE; c++) {
                    cells[r * GRID_SIZE + c].classList.add('highlight');
                }
            });
            
            cols.forEach(c => {
                for (let r = 0; r < GRID_SIZE; r++) {
                    cells[r * GRID_SIZE + c].classList.add('highlight');
                }
            });
            
            setTimeout(() => {
                cells.forEach(cell => cell.classList.remove('highlight'));
            }, 400);
        }

        function showCombo(count) {
            const combo = typeof count === 'number' ? COMBO_MESSAGES[Math.min(count, 6)] : count;
            if (!combo) return;
            
            const effect = document.createElement('div');
            effect.className = 'combo-effect';
            effect.textContent = combo;
            
            document.body.appendChild(effect);
            
            setTimeout(() => effect.remove(), 1000);
        }

        function hasValidMoves() {
            return canPlayWithPieces(game.pieces, game.grid);
        }

        function gameOver() {
            document.getElementById('finalScore').textContent = game.score;
            document.getElementById('gameOverOverlay').classList.add('show');
        }

        function updateScore() {
            document.getElementById('score').textContent = game.score;
            if (game.score > game.highest) {
                game.highest = game.score;
                document.getElementById('highest').textContent = game.highest;
                localStorage.setItem('blockBlastHighest', game.highest);
            }
        }

        function restartGame() {
            game.grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
            game.score = 0;
            game.pieces = generateSmartPieces();
            game.draggingPiece = null;
            game.draggingIndex = -1;
            
            document.getElementById('gameOverOverlay').classList.remove('show');
            
            updateScore();
            drawGrid();
            drawPieces();
        }

        // Load highest score from localStorage
        const savedHighest = localStorage.getItem('blockBlastHighest');
        if (savedHighest) {
            game.highest = parseInt(savedHighest);
        }

        initGrid();
        game.pieces = generateSmartPieces();
        drawGrid();
        drawPieces();
        updateScore();
    </script>
</body>
</html>
